# 計算複雜度 (Computational Complexity)

> 了解線性代數演算法的效能——為什麼 O(n³) 很重要

## 1. 為什麼要關心複雜度？

### 規模的力量

| 矩陣大小 n | O(n²) | O(n³) | O(n⁴) |
|-----------|-------|-------|-------|
| 10 | 100 | 1,000 | 10,000 |
| 100 | 10,000 | 1,000,000 | 100,000,000 |
| 1,000 | 1,000,000 | 1,000,000,000 | 10¹² |

當 n 從 100 變成 1000，O(n³) 演算法慢了 **1000 倍**！

### 實際應用中的規模

| 應用 | 典型矩陣大小 |
|------|-------------|
| 機器學習（小資料集）| n ~ 10³ |
| 有限元素分析 | n ~ 10⁵ - 10⁶ |
| 推薦系統 | n ~ 10⁶ - 10⁸ |
| 大規模圖分析 | n ~ 10⁹ |

---

## 2. 基本運算的複雜度

### 向量運算

| 運算 | 複雜度 | 說明 |
|------|--------|------|
| 向量加法 u + v | O(n) | n 次加法 |
| 純量乘法 cu | O(n) | n 次乘法 |
| 內積 u·v | O(n) | n 次乘法 + n-1 次加法 |
| 向量長度 ‖v‖ | O(n) | 內積 + 開方 |

### 矩陣-向量運算

| 運算 | 複雜度 | 說明 |
|------|--------|------|
| 矩陣-向量乘法 Ax | O(n²) | n 個內積，每個 O(n) |
| 外積 uvᵀ | O(n²) | n² 次乘法 |

### 矩陣-矩陣運算

| 運算 | 複雜度 | 說明 |
|------|--------|------|
| 矩陣加法 A + B | O(n²) | n² 次加法 |
| **矩陣乘法 AB** | **O(n³)** | n² 個元素，每個 O(n) |
| 矩陣轉置 Aᵀ | O(n²) | 或 O(1)（只改索引）|

---

## 3. 解線性方程組的複雜度

### 高斯消去法

```
前進消去 (Forward Elimination):
- 第 1 步：消去 n-1 個元素，每個需要 n 次運算
- 第 2 步：消去 n-2 個元素，每個需要 n-1 次運算
- ...
- 總計：≈ n³/3 次乘法/加法
```

**複雜度：O(n³)**

```
回代 (Back Substitution):
- 第 n 個未知數：1 次除法
- 第 n-1 個未知數：1 次乘法 + 1 次減法 + 1 次除法
- ...
- 總計：≈ n²/2 次運算
```

**複雜度：O(n²)**

### 總結

| 階段 | 複雜度 | 具體運算次數 |
|------|--------|-------------|
| 前進消去 | O(n³) | ≈ 2n³/3 |
| 回代 | O(n²) | ≈ n² |
| **總計** | **O(n³)** | ≈ 2n³/3 + n² |

---

## 4. LU 分解的效率

### 單次求解 vs 多次求解

| 場景 | 方法 | 複雜度 |
|------|------|--------|
| 解 Ax = b（1 個 b）| 高斯消去 | O(n³) |
| 解 Ax = bᵢ（k 個 b）| 每次高斯消去 | k × O(n³) |
| 解 Ax = bᵢ（k 個 b）| **先 LU，再代入** | O(n³) + k × O(n²) |

### 當 k 很大時

```
k = 100, n = 1000

每次高斯消去：100 × 10⁹ = 10¹¹ 次運算
LU + 回代：10⁹ + 100 × 10⁶ = 1.1 × 10⁹ 次運算

LU 分解快了約 100 倍！
```

---

## 5. 反矩陣的複雜度

### 求 A⁻¹

```
高斯-乔丹法：O(n³)
（相當於解 n 個方程組，但可以同時做）
```

### x = A⁻¹b vs solve(A, b)

| 方法 | 複雜度 | 說明 |
|------|--------|------|
| 先求 A⁻¹，再乘 b | O(n³) + O(n²) | 求逆 + 乘法 |
| 直接求解 | O(n³) | 高斯消去 |

**看起來差不多，但實際上：**

1. 求逆的常數因子較大（約 3 倍）
2. 求逆的數值穩定性較差
3. 如果只需要 x，求逆是浪費

---

## 6. 特殊矩陣的效率

### 三角矩陣求解

```
上/下三角系統：O(n²)
（只需回代/前進代入，不需消去）
```

### 帶狀矩陣 (Banded Matrix)

```
帶寬為 p 的矩陣（每列最多 2p+1 個非零元素）

標準高斯消去：O(n³)
帶狀高斯消去：O(n × p²)

當 p << n 時，大幅加速！
```

### 稀疏矩陣

```
有 m 個非零元素的稀疏矩陣

密集存儲：O(n²) 空間
稀疏存儲：O(m) 空間

稀疏乘法：O(m) 而非 O(n²)
```

---

## 7. 更快的演算法

### Strassen 演算法

標準矩陣乘法：O(n³)
Strassen 演算法：O(n^2.807)

**原理：** 用 7 次乘法代替 8 次（2×2 分塊）

**實際應用：** 因為常數因子大，通常 n > 1000 才有優勢

### 目前最佳理論複雜度

矩陣乘法：O(n^2.373)（Alman & Williams, 2020）

但實際演算法複雜度太高，很少使用。

---

## 8. 複雜度分析範例

### 計算 det(A)

```
方法一：展開式
- 有 n! 項
- 複雜度 O(n!)
- n = 20 時需要 2.4 × 10¹⁸ 次運算！

方法二：LU 分解
- 分解 O(n³)
- det = u₁₁ × u₂₂ × ... × uₙₙ
- 複雜度 O(n³)
```

### 求解 A⁻¹b（多個 b）

```
方法一：每次重新計算
- k 個 b：k × O(n³)

方法二：LU 分解 + 回代
- 分解一次：O(n³)
- 每個 b 回代：O(n²)
- 總計：O(n³) + k × O(n²)
```

---

## 9. 程式實作

### 本單元程式示範

| 檔案 | 內容 |
|------|------|
| `complexity_demo.py` | 實測各種演算法的時間複雜度 |

### 實測方法

```python
import time

sizes = [100, 200, 400, 800]
for n in sizes:
    A = np.random.rand(n, n)
    start = time.time()
    # 執行演算法
    elapsed = time.time() - start
    print(f"n = {n}: {elapsed:.4f} s")
```

---

## 10. 考試重點

### 常見題型

1. **複雜度判斷**：給定演算法，判斷複雜度
2. **效率比較**：比較不同方法的效率
3. **優化選擇**：給定場景，選擇最佳演算法

### 關鍵數字

```
矩陣乘法：O(n³)
高斯消去：O(n³)，約 2n³/3 次運算
回代：O(n²)
矩陣-向量乘法：O(n²)
```

### 常見陷阱

- 忽略常數因子（實際效能可能差很多）
- 忽略數值穩定性
- 不考慮記憶體存取模式

---

## 參考資料

- Strang, Chapter 2: Factor Times
- Introduction to Algorithms (CLRS), Chapter 28
- Golub & Van Loan, Matrix Computations
